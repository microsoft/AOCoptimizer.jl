var documenterSearchIndex = {"docs":
[{"location":"background/abstractions/#Abstractions","page":"Abstractions","title":"Abstractions","text":"","category":"section"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"In addition to the QUMO abstraction, where the binary variables take the value 0 or 1, and the continuous variables are in the range -1 1, there are a couple of more variants that may be useful for specific applications:","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"p-QUMO: This is a variant of QUMO where the binary variables take the value 0 or 1, and the continuous variables are in the range 0 1 (i.e., no negative values). This is useful for applications where the continuous variables express allocations (e.g., in portfolio optimization).\nmixed-Ising: This is a variant of QUMO where the binary variables take the value -1 or 1, and the continuous variables are in the range -1 1. This is a natural extension of the Ising model.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"These variants, alongside QUBO, are summarized in the following table:","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":" Continuous: -1 1 Continuous: 0 1 No continuous\nDiscrete: 0 or 1 QUMO p-QUMO QUBO\nDiscrete: -1 or 1 mixed-Ising (n.a.) Ising","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Internally, by default the solver uses the mixed-Ising representation, and there is also support for native solving the QUMO representation. In the absence of continuous variables, the solver is an Ising solver (via the solve function), and a QUBO solver (via the solve_qumo function).","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"TODO: Reference the solve and solve_qumo functions.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Conversions between the different representations are supported via convert_to_qumo (of a mixed Ising problem) convert_to_mixed_ising (of a QUMO problem) convert_positive_qumo_to_mixed_ising (of a p-QUMO problem). Hence, to convert p-QUMO to QUMO, first convert to mixed-Ising, and then to QUMO.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"TODO: Provide direct conversion from p-QUMO to QUMO.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Typically, it is better to express the problem in the more natural form, and then use the existing methods to convert to QUMO or mixed-Ising; this avoid conversion bugs that are often difficult to track down.","category":"page"},{"location":"manual/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"TODO: Provide installation instructions for the package.     In addition, add steps to test that installation has been successful     both when CUDA is and is not used, document installation problems and     differences between platforms.","category":"page"},{"location":"manual/faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"reference/reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/reference/#Generic","page":"Reference","title":"Generic","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.AOCoptimizer","page":"Reference","title":"AOCoptimizer.AOCoptimizer","text":"AOCoptimizer is a Julia package for solving QUBO (Quadratic Unconstrained Binary Optimization) and QUMO (Quadratic Unconstrained Binary Optimization) problems.\n\n\n\n\n\n","category":"module"},{"location":"reference/reference/#AOCoptimizer.Direction","page":"Reference","title":"AOCoptimizer.Direction","text":"Direction\n\nAn enum of possible values for the direction of optimization. The optimizer can either minimize (MINIMIZATION) or maximize (MAXIMIZATION) the objective function.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#Metrics","page":"Reference","title":"Metrics","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.hamiltonian","page":"Reference","title":"AOCoptimizer.hamiltonian","text":"hamiltonian(matrix::AbstractMatrix, x::AbstractVector)\nhamiltonian(matrix::AbstractMatrix, field::Union{Nothing,AbstractVector}, x::AbstractVector)\n\nComputes the Hamiltonian of system with interactions expressed in matrix and for a given assignment x. Optionally, a field can be provided. The matrix is expected to be symmetric.\n\nwarning: Warning\nThe matrix is expected to be symmetric. This is not checked. The field is expected to be a vector of the same size as x. This is not checked.\n\nwarning: Warning\nWe expect that the backend storage for matrix and x is the same. This is not checked.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.graph_cut_from_hamiltonian","page":"Reference","title":"AOCoptimizer.graph_cut_from_hamiltonian","text":"graph_cut_from_hamiltonian(T::Type{<:Real}, graph::AbstractMatrix, hamiltonian::Real)\ngraph_cut_from_hamiltonian(graph::AbstractMatrix, hamiltonian::Real)\ngraph_cut_from_hamiltonian(sum_of_matrix_weights::Real, hamiltonian::Real)\n\nCompute the cut of a graph (represented as a matrix graph, or by providing the sum_of_matrix_weights) from its hamiltonian energy.\n\ntip: Tip\nIf the initial object is a graph, then the sum_of_matrix_weights is the double of the sum of the weights of the graph.\n\ndanger: Danger\nIn addition to assuming that the graph is symmetric (it is not checked), the computation also assumes that the hamiltonian has been computed from the same graph and using a vector assignment of 1 and -1 values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Runtime-system","page":"Reference","title":"Runtime system","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Environment.local_system_info","page":"Reference","title":"AOCoptimizer.Environment.local_system_info","text":"local_system_info()::Dict{String,Any}\n\nCapture the local system information and return it as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Multi-threading","page":"Reference","title":"Multi-threading","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.CancellationToken","page":"Reference","title":"AOCoptimizer.CancellationToken","text":"Cancellation tokens can be used to enable the caller of a task to cancel the task execution\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.RuntimeUtils.RuntimeException","page":"Reference","title":"AOCoptimizer.RuntimeUtils.RuntimeException","text":"RuntimeException\n\nException type for runtime errors.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.create_cancellation_token","page":"Reference","title":"AOCoptimizer.create_cancellation_token","text":"create_cancellation_token()\n\nCreate a cancellation token.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.cancel!","page":"Reference","title":"AOCoptimizer.cancel!","text":"cancel!(ctx)\n\nSend a cancellation message using cancellation token ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.is_cancelled","page":"Reference","title":"AOCoptimizer.is_cancelled","text":"is_cancelled(ctx)\n\nChecks whether cancellation token ctx has been cancelled\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.RuntimeUtils.run_for","page":"Reference","title":"AOCoptimizer.RuntimeUtils.run_for","text":"run_for(fn, timeout; threads)\n\nExecutes function fn for timeout seconds using threads parallel threads. The function fn should accept just one argument, which is a cancellation token; it can return any value. Returns the output of all executions.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#QUBO","page":"Reference","title":"QUBO","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.QUBO.qubo","page":"Reference","title":"AOCoptimizer.QUBO.qubo","text":"qubo{T}\n\nA structure representing a Quadratic Unconstrained Binary Optimization (QUBO) problem. The qubo structure contains the following fields:\n\nSense: The direction of optimization, either MINIMIZATION or MAXIMIZATION.\nTerms: A matrix representing the quadratic and linear terms of the QUBO problem.\n\nAssuming that Q_ij = qTermsi j is the matrix of quadratic terms for q an instance of qubo{T}, the QUBO problem can be expressed as finding a vector of binary variables x = (x_1 x_2 ldots x_n) that minimizes (or, maximizes) the function:\n\nf_Q(x) = sum_i=1^nsum_j=1^n Q_ij x_i x_j\n\nObserve that diagonal elements of the matrix Q (q.Terms) represent linear terms. This economizes space and operations without changing the semantics of the problem. The semantics do not change since w_ii * x_i^2 = w_ii * x_i for any x_i in 0 1 (assuming that w_ii are the diagonal elements of the matrix). However, it is important to adjust the weights of the diagonal elements to express correctly the function f_Q(x). Since w_ij=w_ji, the interaction between the variables x_i and x_j (for ine j) is added twice in f_Q(x), once in the term w_ij x_i x_j and once in w_ji x_j x_i. On the other hand there is a single term for the diagonal elements w_ii x_i^2 = w_ii x_i\n\nwarning: Warning\nConsider doubling the weights of the diagonal elements, if you want to encode an external field!\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.QUBO.size","page":"Reference","title":"AOCoptimizer.QUBO.size","text":"size(q::qubo)::Integer\n\nReturns the size of the QUBO problem represented by q.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUBO.evaluate","page":"Reference","title":"AOCoptimizer.QUBO.evaluate","text":"evaluate(q::qubo, assignment)\n\nEvaluates the objective function of the QUBO problem q for a given assignment. Returns the value of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUBO._random","page":"Reference","title":"AOCoptimizer.QUBO._random","text":"_random(rng::AbstractRNG, q::qubo{T})::AbstractVector{T} where {T<:Real}\n\nGenerates a random assignment for the QUBO problem q using the provided random number generator rng.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUBO.greedy_random","page":"Reference","title":"AOCoptimizer.QUBO.greedy_random","text":"greedy_random(rng::Union{AbstractRNG, Integer}, q::qubo{T}, ctx::Union{Nothing,CancellationToken})\n\nPerforms a greedy random search on the QUBO problem q using the provided random number generator rng. The search continues until the cancellation token ctx is triggered. Returns a tuple containing the best energy found and the corresponding assignment.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUBO.increase!","page":"Reference","title":"AOCoptimizer.QUBO.increase!","text":"increase!(assignment, terms, indices; ctx)\n\nTries to increase the objective function of an assignment applied to a set of QUBO terms by flipping assignments one-by-one according to the order in indices.\n\nIf cancellation token ctx is present, then process will continue until the entire list of indices gets visited, or cancellation token ctx gets triggered.\n\nMethod returns true if progress has been made; false otherwise\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUBO.decrease!","page":"Reference","title":"AOCoptimizer.QUBO.decrease!","text":"decrease(assignment, terms, indices; ctx)\n\nTries to decrease the objective function of an assignment applied to a set of QUBO terms by flipping assignments one-by-one according to the order in indices.\n\nIf cancellation token ctx is present, then process will continue until the entire list of indices gets visited, or cancellation token ctx gets triggered.\n\nMethod returns true if progress has been made; false otherwise\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#QUMO","page":"Reference","title":"QUMO","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.QUMO.mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.mixed_ising","text":"mixed_ising{T}\n\nA structure representing a Mixed Ising problem. Such problems are always minimization problems and, unlike traditional Ising problems, they can contain both binary and continuous variables. The continuous variables have a range of [-1, 1], while the binary variables are in {-1, 1}.\n\nThe mixed_ising structure contains:\n\nQuadratic: A matrix representing the quadratic terms of the Ising problem.\nField: A vector representing the linear terms of the Ising problem.\nBinary: A vector of booleans indicating whether each variable is binary.\nOffset: A constant offset added to the objective function.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.QUMO.qumo","page":"Reference","title":"AOCoptimizer.QUMO.qumo","text":"qumo{T}\n\nA structure representing a Quadratic Unconstrained Mixed Optimization (QUMO). Such problems can be either minimization or maximization problems. They can contain both binary and continuous variables, but the continuous variables are expected to be in the range [-1, 1] and the binary variables are in {0, 1}. The objective function is (1/2)x'Qx + f'x + c, where x is the vector of variables, Q is the quadratic matrix, f is the linear vector (if it exists), and c is a constant offset.\n\nThe qumo structure contains the following fields:\n\nSense: The direction of optimization, either MINIMIZATION or MAXIMIZATION.\nQuadratic: A matrix representing the quadratic terms of the QUMO problem.\nField: A vector representing the linear terms of the QUMO problem.\nBinary: A vector of booleans indicating whether each variable is binary.\nOffset: A constant offset added to the objective function.\n\nIt is expected that the Quadratic matrix is symmetric and that the diagonal elements that correspond to binary variables are zero. (This is not checked in the constructor.)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#Base.isapprox","page":"Reference","title":"Base.isapprox","text":"isapprox(q1::qumo, q2::qumo; kwargs...)\n\nChecks if two qumo objects are approximately equal, i.e., have the same optimization direction and approximately the same weights in the quadratic and linear terms. They should also have the same binary and continuous variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUMO.number_of_variables","page":"Reference","title":"AOCoptimizer.QUMO.number_of_variables","text":"number_of_variables(q::Union{qumo{T}, mixed_ising{T}})::Integer where {T<:Real}\n\nReturns the number of variables in the QUMO or Mixed Ising problem q.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_mixed_ising_to_positive_qumo","page":"Reference","title":"AOCoptimizer.QUMO.convert_mixed_ising_to_positive_qumo","text":"convert_mixed_ising_to_positive_qumo(m::mixed_ising{T})::qumo{T} where T<:Real\n\nConverts a mixed Ising problem, i.e. a problem where binaries are -1 1 and continuous in -1 1 to positive QUMO, where all variables are expected to be positive (binary in 01, continuous in 01).\n\nThe transformation is achieved by observing that we need to scale all variables x by (x+1)2 to move from -11 to 01. Observe, that the optimization objective is (12)xQx + fx + c.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_positive_qumo_to_mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.convert_positive_qumo_to_mixed_ising","text":"convert_positive_qumo_to_mixed_ising(q::qumo{T})::mixed_ising{T} where {T<:Real}\n\nConverts a positive QUMO problem, i.e. a problem where all variables are expected to be positive (binary in 01, continuous in 01) to mixed Ising, where binaries are -1 1 and continuous in -1 1.\n\nThe transformation is achieved by observing that we need to scale all variables x by 2x-1 to move from 01 to -11. Observe, that the optimization objective is (12)xQx + fx + c.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_to_qumo","page":"Reference","title":"AOCoptimizer.QUMO.convert_to_qumo","text":"convert_to_qumo(q::mixed_ising{T})::qumo{T} where {T<:Real}\n\nConverts a mixed Ising problem, i.e., a problem where binaries are -1 1 and continuous in -1 1 to QUMO, where binaries are in 0 1 and continuous stay at -1 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_to_mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.convert_to_mixed_ising","text":"convert_to_mixed_ising(q::qumo{T})::mixed_ising{T} where {T<:Real}\n\nConverts a QUMO problem to a mixed Ising problem. The transformation is achieved by observing that we need to map all binary variables from {0, 1} to {-1, 1}.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Solver","page":"Reference","title":"Solver","text":"","category":"section"},{"location":"reference/reference/#Energy-computations","page":"Reference","title":"Energy computations","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.calculate_energies!","page":"Reference","title":"AOCoptimizer.Solver.calculate_energies!","text":"calculate_energies!(\n    energies::AbstractVector{TEval},\n    spins::AbstractMatrix{T},\n    matrix::AbstractMatrix{TEval},\n    external::Union{Nothing,AbstractVector{TEval}},\n) where {T<:Real,TEval<:Real}\n\nCalculate the energies for each configuration given the spins, the interaction matrix and an optional external field. The energies vector is modified in place to hold the computed energies.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.calculate_energies","page":"Reference","title":"AOCoptimizer.Solver.calculate_energies","text":"calculate_energies(\n    spins::AbstractMatrix{T},\n    matrix::AbstractMatrix{TEval},\n    external::Union{Nothing,AbstractVector{TEval}},\n)::AbstractVector{TEval} where {T<:Real,TEval<:Real}\n\nCalculate the energies for each configuration given the spins, the interaction matrix and an optional external field. The result is returned as a new vector of energies.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.count_min_energy_hits","page":"Reference","title":"AOCoptimizer.Solver.count_min_energy_hits","text":"count_min_energy_hits(observations::TEnergyObservations{<:Real})::AbstractVector{T}\n\nCount the number of experiments that hit the minimum observed energy. In the input matrix, each column corresponds to a configuration and each row corresponds to an experiment. The output is a vector of length equal to the number of columns (configurations) in the input matrix. The entry at index i is the number of experiments that hit the minimum observed energy for configuration i.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Non-linearities-and-walls","page":"Reference","title":"Non-linearities and walls","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.@make_non_linearity","page":"Reference","title":"AOCoptimizer.Solver.@make_non_linearity","text":"@make_non_linearity(name, fn)\n\nMacro to create a non-linearity function that applies the function fn element-wise to an array x.\n\nWhere supported, it will generate optimized code for specific backends (e.g., CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"reference/reference/#AOCoptimizer.Solver.non_linearity_tanh!","page":"Reference","title":"AOCoptimizer.Solver.non_linearity_tanh!","text":"non_linearity_tanh!(x::AbstractArray{T,N}) where {T<:Real,N}\n\nIn-place application of the sign function element-wise to the array x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.non_linearity_sign!","page":"Reference","title":"AOCoptimizer.Solver.non_linearity_sign!","text":"non_linearity_sign!(x::AbstractArray{T,N}) where {T<:Real,N}\n\nIn-place application of the sign function element-wise to the array x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.non_linearity_binary!","page":"Reference","title":"AOCoptimizer.Solver.non_linearity_binary!","text":"non_linearity_binary!(x::AbstractArray{T,N}) where {T<:Real,N}\n\nIn-place application of the function x -> (x>0.5)?1.0:0.0 element-wise to the array x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.@make_wall","page":"Reference","title":"AOCoptimizer.Solver.@make_wall","text":"@make_wall(name, lower, upper)\n\nCreates functions that enforce an inelastic wall for a given name, with specified lower and upper bounds.\n\n\n\n\n\n","category":"macro"},{"location":"reference/reference/#AOCoptimizer.Solver.enforce_inelastic_wall!","page":"Reference","title":"AOCoptimizer.Solver.enforce_inelastic_wall!","text":"enforce_inelastic_wall!(x::AbstractArray{T,N}, upper::T, lower::T) where {T<:Real,N}\nenforce_inelastic_wall!(x::AbstractArray{T,N}, y::AbstractArray{T,N}, upper::T, lower::T) where {T<:Real,N}\n\nEnforces that the elements of x are within the specified lower and upper bounds. If y is provided, it is modified to zero for the corresponding elements for which x exceeds the bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Samplers","page":"Reference","title":"Samplers","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.@make_sampler","page":"Reference","title":"AOCoptimizer.Solver.@make_sampler","text":"@make_sampler(\n    name,\n    binary_non_linearity,\n    walls,\n    bias,\n    inplace_matrix_vector_multiplication,\n    adjust_parameters = nothing,\n    per_iteration_callback = nothing\n)\n\nThis macro generates a sampler function. The generated functions will be named name!. It will use the functions binary_non_linearity and walls to apply the binary non-linearity and the bounds to the variables, respectively. The inplace_matrix_vector_multiplication function will be used to perform the matrix-vector multiplication in-place, which is crucial for performance. It allows to subtract a custom bias from all variables (typically zero, but can be non-zero when simulating physical systems).\n\nThe caller can also provide two extensibility points: (A) adjust_parameters, which allows to adjust the gradient and momentum; (B) per_iteration_callback, which allows to run a callback at the end of each iteration.\n\n\n\n\n\n","category":"macro"},{"location":"reference/reference/#AOCoptimizer.Solver.sampler!","page":"Reference","title":"AOCoptimizer.Solver.sampler!","text":"sampler!(\n    problem::Problem{T, TEval},\n    setup::Setup{T},\n    workspace::Workspace{T},\n    iterations::Integer,\n    annealing_delta::AbstractVector{T},\n    per_iteration_callback_state::Union{Nothing,TIterationCallbackState}=nothing\n) where {T<:Real, TEval<:Real, TIterationCallbackState}\n\nSampler for mixed Ising problems. Arguments include:\n\nproblem contains the input problem. The related matrices will not change.  The computation will be performed using the T elementary data-type, but  the evaluation of the energies will be performed using the TEval data-type.\nsetup contains the setup parameters, such as the gradient, momentum, and dt.  This will not change during the sampling process.\nworkspace contains caller-provided scratch buffers that will be used to perform the sampling. This buffers will change during the sampling process, but the caller should not depend on the values in them after the sampling is done.\niterations is the number of iterations to perform.\nannealing_delta is a vector of the annealing factor values to use. This vector will change during the sampling process, and at the end it will typically contain zeros.\nper_iteration_callback_state is an optional state that will be passed to the per-iteration callback function, if it is provided. This state can be used to collect statistics or to perform other actions at the end of each iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.sampler_qumo!","page":"Reference","title":"AOCoptimizer.Solver.sampler_qumo!","text":"sampler_qumo!(\n    problem::Problem{T, TEval},\n    setup::Setup{T},\n    workspace::Workspace{T},\n    iterations::Integer,\n    annealing_delta::AbstractVector{T},\n    per_iteration_callback_state::Union{Nothing,TIterationCallbackState}=nothing\n) where {T<:Real, TEval<:Real, TIterationCallbackState}\n\nSampler for mixed QUMO problems, where the binaries are {0, 1} and the continuous in [-1, 1]. Arguments include:\n\nproblem contains the input problem. The related matrices will not change.  The computation will be performed using the T elementary data-type, but  the evaluation of the energies will be performed using the TEval data-type.\nsetup contains the setup parameters, such as the gradient, momentum, and dt.  This will not change during the sampling process.\nworkspace contains caller-provided scratch buffers that will be used to perform the sampling. This buffers will change during the sampling process, but the caller should not depend on the values in them after the sampling is done.\niterations is the number of iterations to perform.\nannealing_delta is a vector of the annealing factor values to use. This vector will change during the sampling process, and at the end it will typically contain zeros.\nper_iteration_callback_state is an optional state that will be passed to the per-iteration callback function, if it is provided. This state can be used to collect statistics or to perform other actions at the end of each iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.sampler_binary!","page":"Reference","title":"AOCoptimizer.Solver.sampler_binary!","text":"sampler_binary!(\n    problem::Problem{T, TEval},\n    setup::Setup{T},\n    workspace::Workspace{T},\n    iterations::Integer,\n    annealing_delta::AbstractVector{T},\n    per_iteration_callback_state::Union{Nothing,TIterationCallbackState}=nothing\n) where {T<:Real, TEval<:Real, TIterationCallbackState}\n\nSampler for mixed positive QUMO problems, where the binaries are {0, 1} and the continuous in [0, 1]. Arguments include:\n\nproblem contains the input problem. The related matrices will not change.  The computation will be performed using the T elementary data-type, but  the evaluation of the energies will be performed using the TEval data-type.\nsetup contains the setup parameters, such as the gradient, momentum, and dt.  This will not change during the sampling process.\nworkspace contains caller-provided scratch buffers that will be used to perform the sampling. This buffers will change during the sampling process, but the caller should not depend on the values in them after the sampling is done.\niterations is the number of iterations to perform.\nannealing_delta is a vector of the annealing factor values to use. This vector will change during the sampling process, and at the end it will typically contain zeros.\nper_iteration_callback_state is an optional state that will be passed to the per-iteration callback function, if it is provided. This state can be used to collect statistics or to perform other actions at the end of each iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.SamplerTracer.Periodic","page":"Reference","title":"AOCoptimizer.Solver.SamplerTracer.Periodic","text":"Periodic{TM<:AbstractArray{<:Real,3}}\n\nA tracer that collects the spins at regular intervals.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.SamplerTracer.SamplerWithPlan","page":"Reference","title":"AOCoptimizer.Solver.SamplerTracer.SamplerWithPlan","text":"SamplerWithPlan{TM<:AbstractArray{<:Real,3}}\n\nA tracer that collects the spins at specific iterations, explicitly provided by the user. These sampling points are typically related to the number of iterations that we expect the sampler to run for.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.sampler_with_tracer!","page":"Reference","title":"AOCoptimizer.Solver.sampler_with_tracer!","text":"sampler_with_tracer!(\n    problem::Problem{T, TEval},\n    setup::Setup{T},\n    workspace::Workspace{T},\n    iterations::Integer,\n    annealing_delta::AbstractVector{T},\n    per_iteration_callback_state::Union{Nothing,TIterationCallbackState}=nothing\n) where {T<:Real, TEval<:AbstractMatrix{<:T}, TIterationCallbackState}\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Exploration","page":"Reference","title":"Exploration","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.@make_exploration","page":"Reference","title":"AOCoptimizer.Solver.@make_exploration","text":"make_exploration(name, sampler, assignment_collector = Collector.BestAssignmentCollector())\n\nMacro to create an exploration function with the given name and sampler. The assignment_collector is used to specify which samples to collect during the exploration. By default, it uses Collector.BestAssignmentCollector(), which collects the best assignment found during the exploration.\n\n\n\n\n\n","category":"macro"},{"location":"reference/reference/#AOCoptimizer.Solver.exploration","page":"Reference","title":"AOCoptimizer.Solver.exploration","text":"exploration(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::Integer,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\nexploration(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::TIterationNumberChooser,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\n\nRun the exploration for a mixing-Ising problem with the given problem and initial_setup. The exploration will run for the specified number of iterations and repetitions. The batch_size specifies how many samples to process in parallel. The ctx is a cancellation token that can be used to terminate the exploration (e.g., when the allotted time is over). The rng is the random number generator to use for sampling.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.exploration_qumo","page":"Reference","title":"AOCoptimizer.Solver.exploration_qumo","text":"exploration_qumo(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::Integer,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\nexploration_qumo(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::TIterationNumberChooser,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\n\nRun the exploration for a QUMO problem with the given problem and initial_setup. The exploration will run for the specified number of iterations and repetitions. The batch_size specifies how many samples to process in parallel. The ctx is a cancellation token that can be used to terminate the exploration (e.g., when the allotted time is over). The rng is the random number generator to use for sampling.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.exploration_binary","page":"Reference","title":"AOCoptimizer.Solver.exploration_binary","text":"exploration_binary(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::Integer,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\nexploration_binary(\n    problem::Problem{T,TEval},\n    initial_setup::Setup{T},\n    batch_size::Integer,\n    ctx::CancellationToken,\n    iterations::TIterationNumberChooser,\n    repetitions::Integer,\n    rng::AbstractRNG\n)\n\nRun the exploration for a positive-QUMO problem with the given problem and initial_setup. The exploration will run for the specified number of iterations and repetitions. The batch_size specifies how many samples to process in parallel. The ctx is a cancellation token that can be used to terminate the exploration (e.g., when the allotted time is over). The rng is the random number generator to use for sampling.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.ExplorationResult","page":"Reference","title":"AOCoptimizer.Solver.ExplorationResult","text":"ExplorationResult{T <: Real, TV <: AbstractVector, TM <: AbstractMatrix}\n\nThe result of an exploration phase. It supports the opaque field CollectorAdditionalInfo, which may be used by the collector to store additional information.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.Collector.BestFound","page":"Reference","title":"AOCoptimizer.Solver.Collector.BestFound","text":"BestFound{T<:Real, TV<:AbstractVector}\n\nA structure to hold the best found solution and its objective value. All collectors return this structure (when calling the retrieve method on them).\n\nObserve that the elementary type of the assignment vector can be different from the type of the objective value. For example, the objective may be computed at higher precision (e.g., Float32) than the assignment vector (e.g., Float16).\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.Collector.BestSolutionState","page":"Reference","title":"AOCoptimizer.Solver.Collector.BestSolutionState","text":"BestSolutionState{T<:Real, TV<:AbstractVector}\n\nA state structure to hold the best solution found so far. This structure can be updated with new solutions, and it will keep the best one found so far.\n\nObserve that the elementary type of the assignment vector can be different from the type of the objective value. For example, the objective may be computed at higher precision (e.g., Float32) than the assignment vector (e.g., Float16).\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#Solver-initialization","page":"Reference","title":"Solver initialization","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.AbstractProblem","page":"Reference","title":"AOCoptimizer.Solver.AbstractProblem","text":"AbstractProblem{T<:Real}\n\nAbstract type for specifying the problem to be solved.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.Problem","page":"Reference","title":"AOCoptimizer.Solver.Problem","text":"Problem{T<:Real} <: AbstractProblem{T}\n\nData structure for specifying the problem to be solved. This is the case where the problem has an external field. The problem is specified by the interaction matrix and the external field. The problem can contain both binary and continuous variables. It is assumed that the binary variables are the first indices in the matrix and in the field. It is also required that the diagonal of the interaction matrix for the binary variables is zero. For the continuous, the diagonal can be non-zero, as it represents quadratic terms.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.make_annealing_delta","page":"Reference","title":"AOCoptimizer.Solver.make_annealing_delta","text":"make_annealing_delta(annealing::AbstractVector, iterations::Integer)\nmake_annealing_delta(setup::Setup, iterations::Integer)\n\nReturns a vector of the values to be used for the annealing parameter.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.Setup","page":"Reference","title":"AOCoptimizer.Solver.Setup","text":"Setup{T<:Real}\n\nThis structure holds the configuration parameters that will be used in the solver. The Annealing, Gradient, and Momentum vectors must all have the same length; for each index i, the i-th element of each vector corresponds to the parameters for the i-th experiment. The dt parameter is the time step used in the solver.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.make_empty_setup","page":"Reference","title":"AOCoptimizer.Solver.make_empty_setup","text":"make_empty_setup(setup::Setup{T}, capacity::Integer) where {T<:Real}\n\nCreates an empty Setup instance with the same structure as setup, but with capacity elements in each vector. The vectors are filled with zeros.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.make_setup","page":"Reference","title":"AOCoptimizer.Solver.make_setup","text":"make_setup(\n    annealing::TV,\n    gradient::TV,\n    momentum::TV,\n    dt::T,\n    repetitions::Integer,\n) where {T<:Real,TV<:AbstractVector{T}}\nfunction make_setup(\n    annealing::TV,\n    gradient::TV,\n    momentum::T,\n    dt::T,\n    repetitions::Integer,\n) where {T<:Real,TV<:AbstractVector{T}}\nfunction make_setup(\n    T::Type{<:Real},\n    annealing::AbstractVector{<:Real},\n    gradient::AbstractVector{<:Real},\n    momentum::AbstractVector{<:Real},\n    dt::Real,\n    repetitions::Integer,\n)\nfunction make_setup(\n    T::Type{<:Real},\n    annealing::AbstractVector{<:Real},\n    gradient::AbstractVector{<:Real},\n    momentum::Real,\n    dt::Real,\n    repetitions::Integer,\n)\n\nCreates a Setup instance with the specified annealing, gradient, and momentum vectors, repeated repetitions times. The dt parameter is the time step used in the solver. If T is specified, it converts the vectors to that type.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.Workspace","page":"Reference","title":"AOCoptimizer.Solver.Workspace","text":"Workspace{<:Real}\n\nA workspace contains all the temporaries that the sampler needs. The temporaries are allocated once and can be reused for multiple samples. Use the make_workspace function to create a workspace, and the initialize_workspace to initialize it between re-uses.\n\nAll the matrices below have dimensions equal to the number of variables x number of experiments. The annealing vector has length equal to the number of experiments.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.make_workspace","page":"Reference","title":"AOCoptimizer.Solver.make_workspace","text":"make_workspace(problem::Problem, setup::Setup, number_of_samples::Integer)::Workspace\nmake_workspace(problem::Problem, setup::Setup)::Workspace\n\nCreates a workspace, i.e., a collection of temporary buffers, to be used by the sampler.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.initialize_workspace!","page":"Reference","title":"AOCoptimizer.Solver.initialize_workspace!","text":"initialize_workspace!(\n    rng::AbstractRNG,\n    workspace::Workspace{T},\n    annealing::AbstractVector{T},\n    sampler::TSampler\n) where {T<:Real}\n\nInitializes a workspace by assigning random values to the initial spins. Caller must also pass the initial values for the annealing terms (typically, from the Setup{T} structure), and the sampler for the initial values to use.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.ConfigurationSpace","page":"Reference","title":"AOCoptimizer.Solver.ConfigurationSpace","text":"ConfigurationSpace{T<:Real}\n\nDefines a configuration space, i.e., the set of coefficients for the parameters of the algorithm we are interested in (parameters are annealing, gradient, and momentum coefficients).\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.sample_configuration_space","page":"Reference","title":"AOCoptimizer.Solver.sample_configuration_space","text":"sample_configuration_space(T, number_of_configurations;\n                           annealing::ClosedInterval,\n                           gradient::ClosedInterval,\n                           momentum::ClosedInterval)\n\nGenerates a set of number_of_configurations points that sample the space of valid coefficients for the parameters used by the sampler. The valid values of coefficients are determined by the intervals annealing, gradient and momentum.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Main-solver-methods-and-analysis-of-results","page":"Reference","title":"Main solver methods and analysis of results","text":"","category":"section"},{"location":"reference/reference/#AOCoptimizer.Solver.TEnergyObservations","page":"Reference","title":"AOCoptimizer.Solver.TEnergyObservations","text":"TEnergyObservations{T<:Number}\n\nType alias for a matrix of energy observations for various configurations. Each column corresponds to a configuration and each row corresponds to an experiment.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AOCoptimizer.Solver.@make_solver","page":"Reference","title":"AOCoptimizer.Solver.@make_solver","text":"@make_solver(name, exploration)\n\nMacro to create a solver function that runs the AOC optimizer. The solver will be named name and will use the exploration function.\n\n\n\n\n\n","category":"macro"},{"location":"reference/reference/#AOCoptimizer.Solver.solve","page":"Reference","title":"AOCoptimizer.Solver.solve","text":"solve(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    field::Union{Nothing,AbstractVector{TInput}},\n    binary::Integer,\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nsolve(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nInvokes the AOC solver on a mixed-Ising problem, described by the interactions matrix and the field vector (if provided). The computation is performed with the T primitive type (e.g., Float32, Float64, Float16). The first binary variables in the interactions matrix and in the field vector are treated as binary variables. The first binary diagonal elements of the interactions matrix must be zero. The interactions matrix must be symmetric.\n\nThe computation will be performed in the backend backend, which can be CPU, CUDABackend, etc.\n\nThe solver will run for timeout seconds. That time is divided into three phases:\n\nPhase 1: Exploration of the configuration space with a limited number of iterations; this phase will take phase_1_fraction of the total time.\nPhase 2: Exploration of the configuration space with a larger number of iterations; this phase will take phase_2_fraction of the total time.\nDeep search: A deep search phase, which will run for the remaining time. The number of iterations in this phases is chosen with the deep_search_iterations parameter. The number of iterations may be adjusted based on the capabilities of the backend.\n\nThe configuration space is sampled from the intervals specified in the annealing, gradient, and momentum parameters.\n\nThe dt parameter specifies the time step for the simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.solve_qumo","page":"Reference","title":"AOCoptimizer.Solver.solve_qumo","text":"solve_qumo(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    field::Union{Nothing,AbstractVector{TInput}},\n    binary::Integer,\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nsolve_qumo(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nInvokes the AOC solver on a mixed-Ising problem, described by the interactions matrix and the field vector (if provided). The computation is performed with the T primitive type (e.g., Float32, Float64, Float16). The first binary variables in the interactions matrix and in the field vector are treated as binary variables. The first binary diagonal elements of the interactions matrix must be zero. The interactions matrix must be symmetric.\n\nThe computation will be performed in the backend backend, which can be CPU, CUDABackend, etc.\n\nThe solver will run for timeout seconds. That time is divided into three phases:\n\nPhase 1: Exploration of the configuration space with a limited number of iterations; this phase will take phase_1_fraction of the total time.\nPhase 2: Exploration of the configuration space with a larger number of iterations; this phase will take phase_2_fraction of the total time.\nDeep search: A deep search phase, which will run for the remaining time. The number of iterations in this phases is chosen with the deep_search_iterations parameter. The number of iterations may be adjusted based on the capabilities of the backend.\n\nThe configuration space is sampled from the intervals specified in the annealing, gradient, and momentum parameters.\n\nThe dt parameter specifies the time step for the simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.solve_binary","page":"Reference","title":"AOCoptimizer.Solver.solve_binary","text":"solve_binary(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    field::Union{Nothing,AbstractVector{TInput}},\n    binary::Integer,\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nsolve_binary(\n    T::DataType,\n    interactions::AbstractMatrix{TInput},\n    timeout::Second;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    engine::Engine = get_current_engine(),\n    annealing = ClosedInterval(0.01, 1.0),\n    gradient = ClosedInterval(0.01, 1.0),\n    momentum = ClosedInterval(0.95, 0.99),\n    deep_search_iterations = ClosedInterval(500, 20000),\n    dt::Real = 0.5,\n    phase_1_fraction::Real = 0.1,\n    phase_2_fraction::Real = 0.2,\n)\n\nInvokes the AOC solver on a problem where the binary variables are either 0 or 1, and the continuous in the range [0, 1]. The problem is described by the interactions matrix and the field vector (if provided). The computation is performed with the T primitive type (e.g., Float32, Float64, Float16). The first binary variables in the interactions matrix and in the field vector are treated as binary variables. The first binary diagonal elements of the interactions matrix must be zero. The interactions matrix must be symmetric.\n\nThe computation will be performed in the backend backend, which can be CPU, CUDABackend, etc.\n\nThe solver will run for timeout seconds. That time is divided into three phases:\n\nPhase 1: Exploration of the configuration space with a limited number of iterations; this phase will take phase_1_fraction of the total time.\nPhase 2: Exploration of the configuration space with a larger number of iterations; this phase will take phase_2_fraction of the total time.\nDeep search: A deep search phase, which will run for the remaining time. The number of iterations in this phases is chosen with the deep_search_iterations parameter. The number of iterations may be adjusted based on the capabilities of the backend.\n\nThe configuration space is sampled from the intervals specified in the annealing, gradient, and momentum parameters.\n\nThe dt parameter specifies the time step for the simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.get_solver_results_summary","page":"Reference","title":"AOCoptimizer.Solver.get_solver_results_summary","text":"get_solver_results_summary(solver_results)\n\nComputes the relevant statistics for the solver results\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.find_best","page":"Reference","title":"AOCoptimizer.Solver.find_best","text":"find_best(results)\n\nFind the best result from the results of a run of solve. It returns the best Hamiltonian and the corresponding assignment in the variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.search_for_best_configuration","page":"Reference","title":"AOCoptimizer.Solver.search_for_best_configuration","text":"search_for_best_configuration(results::ExplorationResult)\nsearch_for_best_configuration(results::PhaseStatistics)\nsearch_for_best_configuration(results::TRuntimeInfo)\n\nSearches for the best objective value in the results returned by the solver. It returns the best objective value, as well as other statistics about the solution.\n\nCAUTION: Given the different possible inputs, there is variability in the type of the output. Do not take a strong dependency on the output of this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.extract_runtime_information","page":"Reference","title":"AOCoptimizer.Solver.extract_runtime_information","text":"extract_runtime_information(results)\n\nExtracts only runtime information from the results of the solver (ignoring the solution found, objectives, etc.)\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Internal","page":"Reference","title":"Internal","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"The following internal methods are not intended for direct use.","category":"page"},{"location":"reference/reference/#AOCoptimizer.Solver._widen_for_eval","page":"Reference","title":"AOCoptimizer.Solver._widen_for_eval","text":"_widen_for_eval(T::DataType)\n\nHelper function to determine the data type to use for computing the energies. The main challenge is that evaluating energies using Float16 or BFloat16 leads to numerical inaccuracies and incorrect results. Hence, for picking the best configurations, we use a wider data type.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._find_and_display_negative_values","page":"Reference","title":"AOCoptimizer.Solver._find_and_display_negative_values","text":"_find_and_display_negative_values(x::AbstractVector{T}; max_to_print=5) where {T<:Real}\n\nInternal method used for debugging purposes. It finds negative values in the vector x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._get_time_to_solution","page":"Reference","title":"AOCoptimizer.Solver._get_time_to_solution","text":"_get_time_to_solution(success_rate, time)\n\nComputes the time to achieve the best seen solution with 99% confidence\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._get_num_operations_to_solution","page":"Reference","title":"AOCoptimizer.Solver._get_num_operations_to_solution","text":"_get_num_operations_to_solution(success_rate, operations_per_deep_search)\n\nComputes the number of matrix-vector multiplications (i.e., basic operations) to perform to achieve the best seen solution with 99% confidence.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._are_all_diags_zero","page":"Reference","title":"AOCoptimizer.Solver._are_all_diags_zero","text":"_are_all_diags_zero(m::AbstractMatrix{T}, binary::Integer) where {T<:Real}\n\nCheck if all the diagonal elements of the matrix m are zero. For valid (mixed-)Ising and QUMO/QUBO problems, we require that all diagonal elements that correspond to binary variables ({-1, 1} spins for Ising) are zero; those terms, if necessary, should be folded into the external field (for QUMO/QUBO) or the constant term (for Ising). If binary is provided, it specifies the number of binary variables, and only the first binary diagonal elements are checked.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._MAX_NUMBER_OF_CPU_THREADS","page":"Reference","title":"AOCoptimizer.Solver._MAX_NUMBER_OF_CPU_THREADS","text":"_MAX_NUMBER_OF_CPU_THREADS()::Integer\n\nReturns the number of CPU threads to use when running the solver in the CPU.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._dispose","page":"Reference","title":"AOCoptimizer.Solver._dispose","text":"_dispose(x::Any)\n\nThis function serves as a marker to indicate that the object x is not used anymore and can be disposed of.\n\n\n\n\n\n_dispose(workspace::Workspace)\n\nThis function serves mostly as a marker to indicate that the workspace is not used anymore and can be disposed of.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver._optimal_batch_size","page":"Reference","title":"AOCoptimizer.Solver._optimal_batch_size","text":"_optimal_batch_size(backend::Backend, problem::Problem)::Integer\n_optimal_batch_size(problem::Problem)::Integer\n\nInternal method to compute the optimal batch size when solving a problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#AOCoptimizer.Solver.Collector._default_best_assignment_collector","page":"Reference","title":"AOCoptimizer.Solver.Collector._default_best_assignment_collector","text":"_default_best_assignment_collector\n\nInternal variable to hold an object of the BestAssignmentCollector type.\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/example/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"tutorials/example/#Solving-a-simple-MaxCut-problem-using-the-Ising-formulation","page":"Examples","title":"Solving a simple MaxCut problem using the Ising formulation","text":"","category":"section"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"The following is a simple example of using the AOC optimizer to solve a MaxCut problem. Searching for the maximum cut of a graph can be converted to an Ising optimization problem (by negating the adjacency matrix of the graph and searching for the spin assignment that minimized the Hamiltonian); it is also equivalent to a Quadratic Unconstrained Binary Optimization (QUBO) problem (transformation not shown here).","category":"page"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"using Dates\nusing JSON\nusing AOCoptimizer\nusing AOCoptimizer: graph_cut_from_hamiltonian\nusing AOCoptimizer.Solver: solve, find_best, get_solver_results_summary\n\n# Necessary to explicitly initialize the AOCoptimizer package\nAOCoptimizer.init()\n\ngraph = Float32.([\n    0 1 0 0 1\n    1 0 1 0 0\n    0 1 0 1 0\n    0 0 1 0 1\n    1 0 0 1 0\n])\n\n# observe that we optimize the negative of the adjacency matrix of the graph\nsol = solve(Float32, -graph, Second(10))\nbest = find_best(sol)\ncut = graph_cut_from_hamiltonian(graph, best.Objective)\nprintln(\"Energy: \", best.Objective, \"; Cut: \", cut)\nprintln(\"Assignment: \", best.Vars)","category":"page"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"More statistics reported as follows:","category":"page"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"println(JSON.json(get_solver_results_summary(sol), 4));","category":"page"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"Detailed measurements are collected in the sol object:","category":"page"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"println(\"Number of solver iterations in deep search: \", length(sol[:deep_search].results))\nif length(sol[:deep_search].results) > 0\n    println(\"Sample set of measurements:\")\n    lx = min(10, size(sol[:deep_search].results[1].Measurements, 1))\n    ly = min(10, size(sol[:deep_search].results[1].Measurements, 2))\n    show(stdout, MIME\"text/plain\"(), sol[:deep_search].results[1].Measurements[1:lx, 1:ly])\nend","category":"page"},{"location":"tutorials/example/#Solving-a-simple-QUMO-problem","page":"Examples","title":"Solving a simple QUMO problem","text":"","category":"section"},{"location":"tutorials/example/","page":"Examples","title":"Examples","text":"using AOCoptimizer.Solver","category":"page"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms","page":"API Reference","title":"AOCoptimizerAlgorithms","text":"","category":"section"},{"location":"submodules/Algorithms/reference/#Enhanced-Random","page":"API Reference","title":"Enhanced Random","text":"","category":"section"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms.EnhancedRandom.search","page":"API Reference","title":"AOCoptimizer.Algorithms.EnhancedRandom.search","text":"search(rng::AbstractRNG, matrix::AbstractMatrix{T}, ctx::CancellationToken)\nsearch(seed::Integer, matrix::AbstractMatrix{T}, ctx::CancellationToken)\nsearch(rng::AbstractRNG, matrix::AbstractMatrix{T}, field::AbstractVector{T}, ctx::CancellationToken)\nsearch(seed::Integer, matrix::AbstractMatrix{T}, field::AbstractVector{T}, ctx::CancellationToken)\n\nImplement a simple heuristic that tries to solve Ising problems, by starting from a number of random solutions and sequentially trying to improve them using single flips.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms.EnhancedRandom.search_qumo","page":"API Reference","title":"AOCoptimizer.Algorithms.EnhancedRandom.search_qumo","text":"search_qumo(rng::AbstractRNG, quadratic::QuadraticMatrix{T}, linear::AbstractVector{T}, ctx::CancellationToken)\nsearch_qumo(seed::Integer, quadratic::QuadraticMatrix{T}, linear::AbstractVector{T}, ctx::CancellationToken)\nsearch_qumo(rng::AbstractRNG, quadratic::QuadraticMatrix{T}, ctx::CancellationToken)\nsearch_qumo(seed::Integer, quadratic::QuadraticMatrix{T}, ctx::CancellationToken)\n\nImplement a simple heuristic that tries to solve QUMO problems, by starting from a number of random solutions and sequentially trying to improve them using single flips.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats","page":"API Reference","title":"AOCoptimizer.FileFormats","text":"","category":"section"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.FileNotFoundException","page":"API Reference","title":"AOCoptimizer.FileFormats.FileNotFoundException","text":"FileNotFoundException(filename::AbstractString, message::AbstractString)\n\nException thrown when a file does not exist.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.GraphIOException","page":"API Reference","title":"AOCoptimizer.FileFormats.GraphIOException","text":"Exception thrown when encountering errors in parsing files\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#Simple-graph-file-format","page":"API Reference","title":"Simple graph file format","text":"","category":"section"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.read_graph_matrix","page":"API Reference","title":"AOCoptimizer.FileFormats.read_graph_matrix","text":"read_graph_matrix(io)\n\nRead an undirected graph from an I/O stream.\n\nThe format of the file should be:\n\nnumber_of_vertices number_of_edges\nendpoint_A_of_edge_1 endpoint_B_of_edge_1 weight_of_edge_1\nendpoint_A_of_edge_2 endpoint_B_of_edge_2 weight_of_edge_2\n....\n\n\n\n\n\nread_graph_matrix(filename)\n\nRead an undirected graph from a file with name filename.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.read_directed_graph_matrix","page":"API Reference","title":"AOCoptimizer.FileFormats.read_directed_graph_matrix","text":"read_directed_graph_matrix(io)\n\nRead a directed graph from an I/O stream.\n\nThe format of the file should be:\n\nnumber_of_vertices number_of_edges\nendpoint_A_of_edge_1 endpoint_B_of_edge_1 weight_of_edge_1\nendpoint_A_of_edge_2 endpoint_B_of_edge_2 weight_of_edge_2\n....\n\n\n\n\n\nread_directed_graph_matrix(filename)\n\nRead an undirected graph from a file with name filename.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#QIO-file-format","page":"API Reference","title":"QIO file format","text":"","category":"section"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QIOProblem","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QIOProblem","text":"QIOProblem\n\nAbstract type for QIO problems.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.Ising","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.Ising","text":"Ising{T<:Real} <: QIOProblem\n\nIsing problem type. Ising problems are represented with a matrix of coefficients and a vector of fields.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QUBO","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QUBO","text":"QUBO{T<:Real} <: QIOProblem\n\nQUBO problem type. QUBO problems are represented as a matrix of coefficients. These instances do not contain linear terms.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.Metadata","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.Metadata","text":"Metadata{T<:Real}\n\nMetadata for QIO problems. Metadata include the following fields:\n\nObjective: The objective value of the problem; this is the best known minimum or maximum value of the objective function.\nInstance: The name of the instance; this can be used to identify the problem.\nSense: The optimization direction (MINIMIZATION or MAXIMIZATION).\nNumberOfTerms: The number of terms in the problem.\nNumberOfInteractions: The number of interactions in the problem.\nMaxDegree: The maximum degree of the problem.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QIOException","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QIOException","text":"QIOException(msg::AbstractString)\n\nException thrown when encountering errors in parsing files\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.read_qio","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.read_qio","text":"read_qio(::Type{T}, filename::AbstractString)::QIOProblem where {T<:Real}\nread_qio(filename::AbstractString)::QIOProblem\nread_qio(::Type{T}, io::IO)::QIOProblem where {T<:Real}\nread_qio(io::IO)::QIOProblem\n\nRead a QIO problem from a file with name filename or from an IO stream io. Optional type parameter T specifies the elementary type used in the the problem (e.g., Float64 or Float32).\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.is_qubo","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.is_qubo","text":"is_qubo(::QIOProblem) -> Bool\n\nCheck if the problem is a QUBO problem.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.is_ising","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.is_ising","text":"is_ising(::QIOProblem) -> Bool\n\nCheck if the problem is an Ising problem.\n\n\n\n\n\n","category":"function"},{"location":"developer/TODOs/#TODOs","page":"TODOs","title":"TODOs","text":"","category":"section"},{"location":"developer/TODOs/#Filename:-docs/src/index.md","page":"TODOs","title":"Filename: docs/src/index.md","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Add a simple example in the code above\nLine 76 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/docs/src/index.md [offset: 3305]","category":"page"},{"location":"developer/TODOs/#Filename:-docs/src/background/abstractions.md","page":"TODOs","title":"Filename: docs/src/background/abstractions.md","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Reference the solve and solve_qumo functions.\nLine 37 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/docs/src/background/abstractions.md [offset: 1651]","category":"page"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Provide direct conversion from p-QUMO to QUMO.\nLine 45 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/docs/src/background/abstractions.md [offset: 2165]","category":"page"},{"location":"developer/TODOs/#Filename:-docs/src/manual/installation.md","page":"TODOs","title":"Filename: docs/src/manual/installation.md","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Provide installation instructions for the package.\nLine 3 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/docs/src/manual/installation.md [offset: 16]\nNotes: In addition, add steps to test that installation has been successful   both when CUDA is and is not used, document installation problems and   differences between platforms.","category":"page"},{"location":"developer/TODOs/#Filename:-ext/CUDAExt/engine.jl","page":"TODOs","title":"Filename: ext/CUDAExt/engine.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Have to adapt the following heuristic to the specific hardware.\nLine 39 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/ext/CUDAExt/engine.jl [offset: 1120]\nNotes: return cld(6.0e7 * problem.Size^(-1.381), 1)","category":"page"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"end","category":"page"},{"location":"developer/TODOs/#Filename:-scripts/optimize.jl","page":"TODOs","title":"Filename: scripts/optimize.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Read input file and process; log result\nLine 182 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/scripts/optimize.jl [offset: 4601]\nNotes: error(\"Processing of input files is not implemented yet\")","category":"page"},{"location":"developer/TODOs/#Filename:-src/precompile.jl","page":"TODOs","title":"Filename: src/precompile.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Precompile common cases\nLine 6 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/precompile.jl [offset: 116]","category":"page"},{"location":"developer/TODOs/#Filename:-src/qubo.jl","page":"TODOs","title":"Filename: src/qubo.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Greedy heuristic in GPU\nLine 6 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/qubo.jl [offset: 59]\nNotes: The code below implements a very simple greedy heuristic for QUBO problems.   The heuristic is used for benchmarking purposed (e.g., what a very naive   algorithm can do). The implementation is CPU-based. Ideally, we would like   to implement a GPU-based version of the algorithm.","category":"page"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Consider the choice of embedding the linear terms in the diagonal of the QUBO matrix\nLine 12 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/qubo.jl [offset: 381]\nNotes: The current implementation embeds the linear terms in the diagonal of the QUBO matrix.   This is a common practice. However. it may lead to usability issues and confusion.   We may need to reconsider this choice in the future.","category":"page"},{"location":"developer/TODOs/#Filename:-src/Algorithms/enhanced_random.jl","page":"TODOs","title":"Filename: src/Algorithms/enhanced_random.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Add unit tests for the methods in EnhancedRandom\nLine 16 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/Algorithms/enhanced_random.jl [offset: 509]","category":"page"},{"location":"developer/TODOs/#Filename:-src/FileFormats/qio.jl","page":"TODOs","title":"Filename: src/FileFormats/qio.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Document the QIO file format.\nLine 8 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/FileFormats/qio.jl [offset: 152]\nNotes: This is a custom JSON format that describes Ising and PUBO problems.","category":"page"},{"location":"developer/TODOs/#Filename:-src/Solver/core.jl","page":"TODOs","title":"Filename: src/Solver/core.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Improve the estimate of the rate of iterations\nLine 253 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/Solver/core.jl [offset: 9933]\nNotes: =#           maxpossibleiterations = 4*ceil(Int, remainingtime * estimateiterationspersec)","category":"page"},{"location":"developer/TODOs/#Filename:-src/Solver/estimators.jl","page":"TODOs","title":"Filename: src/Solver/estimators.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Improve heuristics for computing optimal batch size.\nLine 91 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/Solver/estimators.jl [offset: 2316]","category":"page"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: Identify the best number of CPU threads to use for each architecture.\nLine 129 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/Solver/estimators.jl [offset: 3985]\nNotes: =#","category":"page"},{"location":"developer/TODOs/#Filename:-src/Solver/results_stats.jl","page":"TODOs","title":"Filename: src/Solver/results_stats.jl","text":"","category":"section"},{"location":"developer/TODOs/","page":"TODOs","title":"TODOs","text":"Title: We are computing twice. The problem is that the first attempts outputs all iterations\nLine 114 of /home/runner/work/AOCoptimizer.jl/AOCoptimizer.jl/src/Solver/results_stats.jl [offset: 3993]","category":"page"},{"location":"developer/developer/#Developer-notes","page":"Developer notes","title":"Developer notes","text":"","category":"section"},{"location":"developer/developer/#Helpful-links","page":"Developer notes","title":"Helpful links","text":"","category":"section"},{"location":"developer/developer/","page":"Developer notes","title":"Developer notes","text":"Documentation of KernelAbstractions.jl","category":"page"},{"location":"changelog/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#Release-Notes","page":"Release notes","title":"Release Notes","text":"","category":"section"},{"location":"manual/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"submodules/Algorithms/overview/#AOCoptimizer.Algorithms","page":"Overview","title":"AOCoptimizer.Algorithms","text":"","category":"section"},{"location":"submodules/Algorithms/overview/#Enhanced-Random","page":"Overview","title":"Enhanced Random","text":"","category":"section"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"This module implements a very simple heuristic for solving Ising and QUMO problems. It is based on the idea of starting from a random initial solution, and then iteratively flipping bits in the assignment vector to improve the objective function. The algorithm evaluated starting points in parallel and (typically) executes for a specified time limit. The achieved solution can be used as the lowest baseline that any reasonable algorithm should be able to beat.","category":"page"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"A simple example of how to use it is shown below:","category":"page"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"using AOCoptimizer: CancellationToken\nusing AOCoptimizer.RuntimeUtils: run_for\nusing AOCoptimizer.Algorithms.EnhancedRandom: search\n\nfunction _mk_solver(interactions::AbstractMatrix, seed::Integer)\n\n    function solve(ctx::CancellationToken)\n        # @debug \"Starting solver at $(now())\"\n        # @debug \"Graph: $interactions\"\n        # @debug \"Context: $ctx\"\n        result = search(seed, interactions, ctx)\n        # @debug \"Solver finished at $(now())\"\n        return result\n    end\n\n    return solve\nend\n\ninteractions = Float32.(-[\n    0 1 0 0\n    1 0 0 0\n    0 0 0 1\n    0 0 1 0\n])\nseed = 1234\ntime_limit = Second(2)\n\nsolver = _mk_solver(interactions, seed)\nresults = run_for(solver, time_limit; threads=2)\n\n(best_objective, best_index) = findmin(first, results)\nbest_assignment = results[best_index][2]\nprintln(\"Best objective: $best_objective\")\nprintln(\"Best (ising) assignment: $best_assignment\")","category":"page"},{"location":"#AOCoptimizer.jl","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Welcome to the documentation of the AOCoptimizer.jl Julia package. AOCoptimizer.jl is a package for solving Quadratic Unconstrained Mixed Optimization (QUMO) problems.","category":"page"},{"location":"#The-QUMO-Abstraction","page":"AOCoptimizer.jl","title":"The QUMO Abstraction","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"QUMO is a new abstraction designed for expressing practical optimization problems that aligns seamlessly with innovative hardware solutions (e.g., Project AOC). QUMO broadens the scope of the established models often referred to as Ising, Max-Cut, or Quadratic Unconstrained Binary Optimization (QUBO), by allowing continuous variables alongside binary variables. The QUMO extension allows a more natural expression of problems involving both continuous and binary (decision) variables, eliminating the need for the binarization of continuous variables that increases problem size. In addition, QUMO efficiently integrates inequality constraints by introducing a single continuous slack variable for each constraint. Hence, the QUMO abstraction represents practical problems using fewer variables and by staying closer to the original problem formulation, it often yields better solutions than QUBO.","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Formally, QUMO seeks an assignment to N variables bf x=leftx_1 ldots  x_Nright^T of the objective:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"  min_bf x -frac12 bf x^T cdot bf Q cdot bf x - bf q^Tcdot bf x =\n  min_bf x -frac12 sum_i=1^N Q_ii x^2_i -\n  frac12sum_substackij=1  i neq j^N Q_ijx_ix_j - sum_i=1^N q_i x_i","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"for a given matrix bf Q and vector bf q representing the problem. The variables can be either binary, i.e., x_i in 0 1, or continuous in the (closed) range, i.e., x_i in left-1 1right, while the matrix bf Q is symmetric, i.e., Q_ij = Q_ji. We do not require semi-definiteness or convexity for the input problem. The diagonal entries of bf Q are zero for the binary variables, as quadratic terms of the form Q_ii x_i^2 are equivalent to Q_ii x_i and, hence, can be incorporated into the relevant linear terms by updating q_i accordingly, i.e., q_i leftarrow q_i + 05cdot Q_ii and then Q_ii leftarrow 0.","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"For more details on the QUMO and related abstractions, please refer to the abstractions section of the documentation.","category":"page"},{"location":"#Installation-and-Usage","page":"AOCoptimizer.jl","title":"Installation and Usage","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"In a nutshell, you can install the package using the Julia package manager:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"] add https://github.com/microsoft/AOCoptimizer.jl\n# or\nusing Pkg\nPkg.add(url=\"https://github.com/microsoft/AOCoptimizer.jl\", rev=\"main\")","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"After successful installation, you can use the package by loading it:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"# if you want to use CUDA, first uncomment the following line to load CUDA.jl\n# using CUDA\nusing AOCoptimizer\nAOCoptimizer.init()  # necessary to initialize the package","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Unit tests should also work correctly (it may take a while to finish):","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"] test AOCoptimizer\n# or\nusing Pkg\nPkg.test(\"AOCoptimizer\")","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"TODO: Add a simple example in the code above","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"For more detailed installation instructions and related problems, please refer to the installation section of the documentation.","category":"page"}]
}
