var documenterSearchIndex = {"docs":
[{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"CurrentModule = AOCoptimizer\nDocTestSetup = quote\n    import AOCoptimizer as AOC\nend\nDocTestFilters = [r\"AOCoptimizer|AOC\"]","category":"page"},{"location":"background/abstractions/#Abstractions","page":"Abstractions","title":"Abstractions","text":"","category":"section"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"In addition to the QUMO abstraction, where the binary variables take the value 0 or 1, and the continuous variables are in the range -1 1, there are a couple of more variants that may be useful for specific applications:","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"p-QUMO: This is a variant of QUMO where the binary variables take the value 0 or 1, and the continuous variables are in the range 0 1 (i.e., no negative values). This is useful for applications where the continuous variables express allocations (e.g., in portfolio optimization).\nmixed-Ising: This is a variant of QUMO where the binary variables take the value -1 or 1, and the continuous variables are in the range -1 1. This is a natural extension of the Ising model.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"These variants, alongside QUBO, are summarized in the following table:","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":" Continuous: -1 1 Continuous: 0 1 No continuous\nDiscrete: 0 or 1 QUMO p-QUMO QUBO\nDiscrete: -1 or 1 mixed-Ising (n.a.) Ising","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Internally, by default the solver uses the mixed-Ising representation, and there is also support for native solving the QUMO representation. In the absence of continuous variables, the solver is effectively an Ising solver (via the solve function), and a QUBO solver (via the solve_qumo function).","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"TODO: Reference the solve and solve_qumo functions.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Conversions between the different representations are supported via convert_to_qumo (of a mixed Ising problem) convert_to_mixed_ising (of a QUMO problem) convert_positive_qumo_to_mixed_ising (of a p-QUMO problem). Hence, to convert p-QUMO to QUMO, first convert to mixed-Ising, and then to QUMO.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"TODO: Provide direct conversion from p-QUMO to QUMO.","category":"page"},{"location":"background/abstractions/","page":"Abstractions","title":"Abstractions","text":"Typically, it is better to express the problem in the more natural form, and then use the existing methods to convert to QUMO or mixed-Ising; this avoid conversion bugs that are often difficult to track down.","category":"page"},{"location":"manual/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"TODO: Provide installation instructions for the package.     In addition, add steps to test that installation has been successful     both when CUDA is and is not used, document installation problems and     differences between platforms.","category":"page"},{"location":"manual/faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"CurrentModule = AOCoptimizer\nDocTestSetup = quote\n    import AOCoptimizer as AOC\nend\nDocTestFilters = [r\"AOCoptimizer|AOC\"]","category":"page"},{"location":"reference/reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/reference/#Generic","page":"Reference","title":"Generic","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"AOCoptimizer","category":"page"},{"location":"reference/reference/#AOCoptimizer.AOCoptimizer","page":"Reference","title":"AOCoptimizer.AOCoptimizer","text":"AOCoptimizer is a Julia package for solving QUBO (Quadratic Unconstrained Binary Optimization) and QUMO (Quadratic Unconstrained Binary Optimization) problems.\n\n\n\n\n\n","category":"module"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"Direction","category":"page"},{"location":"reference/reference/#AOCoptimizer.Direction","page":"Reference","title":"AOCoptimizer.Direction","text":"Direction\n\nAn enum of possible values for the direction of optimization. The optimizer can either minimize (MINIMIZATION) or maximize (MAXIMIZATION) the objective function.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#Metrics","page":"Reference","title":"Metrics","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"hamiltonian","category":"page"},{"location":"reference/reference/#AOCoptimizer.hamiltonian","page":"Reference","title":"AOCoptimizer.hamiltonian","text":"hamiltonian(matrix::AbstractMatrix, x::AbstractVector)\nhamiltonian(matrix::AbstractMatrix, field::Union{Nothing,AbstractVector}, x::AbstractVector)\n\nComputes the Hamiltonian of system with interactions expressed in matrix and for a given assignment x. Optionally, a field can be provided. The matrix is expected to be symmetric.\n\nwarning: Warning\nThe matrix is expected to be symmetric. This is not checked. The field is expected to be a vector of the same size as x. This is not checked.\n\nwarning: Warning\nWe expect that the backend storage for matrix and x is the same. This is not checked.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"graph_cut_from_hamiltonian","category":"page"},{"location":"reference/reference/#AOCoptimizer.graph_cut_from_hamiltonian","page":"Reference","title":"AOCoptimizer.graph_cut_from_hamiltonian","text":"graph_cut_from_hamiltonian(T::Type{<:Real}, graph::AbstractMatrix, hamiltonian::Real)\ngraph_cut_from_hamiltonian(graph::AbstractMatrix, hamiltonian::Real)\ngraph_cut_from_hamiltonian(sum_of_matrix_weights::Real, hamiltonian::Real)\n\nCompute the cut of a graph (represented as a matrix graph, or by providing the sum_of_matrix_weights) from its hamiltonian energy.\n\ntip: Tip\nIf the initial object is a graph, then the sum_of_matrix_weights is the double of the sum of the weights of the graph.\n\ndanger: Danger\nIn addition to assuming that the graph is symmetric (it is not checked), the computation also assumes that the hamiltonian has been computed from the same graph and using a vector assignment of 1 and -1 values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Multi-threading","page":"Reference","title":"Multi-threading","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"CancellationToken","category":"page"},{"location":"reference/reference/#AOCoptimizer.CancellationToken","page":"Reference","title":"AOCoptimizer.CancellationToken","text":"Cancellation tokens can be used to enable the caller of a task to cancel the task execution\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"RuntimeUtils.RuntimeException","category":"page"},{"location":"reference/reference/#AOCoptimizer.RuntimeUtils.RuntimeException","page":"Reference","title":"AOCoptimizer.RuntimeUtils.RuntimeException","text":"RuntimeException\n\nException type for runtime errors.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"create_cancellation_token","category":"page"},{"location":"reference/reference/#AOCoptimizer.create_cancellation_token","page":"Reference","title":"AOCoptimizer.create_cancellation_token","text":"create_cancellation_token()\n\nCreate a cancellation token.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"cancel!","category":"page"},{"location":"reference/reference/#AOCoptimizer.cancel!","page":"Reference","title":"AOCoptimizer.cancel!","text":"cancel!(ctx)\n\nSend a cancellation message using cancellation token ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"is_cancelled","category":"page"},{"location":"reference/reference/#AOCoptimizer.is_cancelled","page":"Reference","title":"AOCoptimizer.is_cancelled","text":"is_cancelled(ctx)\n\nChecks whether cancellation token ctx has been cancelled\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"RuntimeUtils.run_for","category":"page"},{"location":"reference/reference/#AOCoptimizer.RuntimeUtils.run_for","page":"Reference","title":"AOCoptimizer.RuntimeUtils.run_for","text":"run_for(fn, timeout; threads)\n\nExecutes function fn for timeout seconds using threads parallel threads. The function fn should accept just one argument, which is a cancellation token; it can return any value. Returns the output of all executions.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#QUBO","page":"Reference","title":"QUBO","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.qubo","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.qubo","page":"Reference","title":"AOCoptimizer.QUBO.qubo","text":"qubo{T}\n\nA structure representing a Quadratic Unconstrained Binary Optimization (QUBO) problem. The qubo structure contains the following fields:\n\nSense: The direction of optimization, either MINIMIZATION or MAXIMIZATION.\nTerms: A matrix representing the quadratic and linear terms of the QUBO problem.\n\nAssuming that Q_ij = qTermsi j is the matrix of quadratic terms for q an instance of qubo{T}, the QUBO problem can be expressed as finding a vector of binary variables x = (x_1 x_2 ldots x_n) that minimizes (or, maximizes) the function:\n\nf_Q(x) = sum_i=1^nsum_j=1^n Q_ij x_i x_j\n\nObserve that diagonal elements of the matrix Q (q.Terms) represent linear terms. This economizes space and operations without changing the semantics of the problem. The semantics do not change since w_ii * x_i^2 = w_ii * x_i for any x_i in 0 1 (assuming that w_ii are the diagonal elements of the matrix). However, it is important to adjust the weights of the diagonal elements to express correctly the function f_Q(x). Since w_ij=w_ji, the interaction between the variables x_i and x_j (for ine j) is added twice in f_Q(x), once in the term w_ij x_i x_j and once in w_ji x_j x_i. On the other hand there is a single term for the diagonal elements w_ii x_i^2 = w_ii x_i\n\nwarning: Warning\nConsider doubling the weights of the diagonal elements, if you want to encode an external field!\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.size","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.size","page":"Reference","title":"AOCoptimizer.QUBO.size","text":"size(q::qubo)::Integer\n\nReturns the size of the QUBO problem represented by q.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.evaluate","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.evaluate","page":"Reference","title":"AOCoptimizer.QUBO.evaluate","text":"evaluate(q::qubo, assignment)\n\nEvaluates the objective function of the QUBO problem q for a given assignment. Returns the value of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO._random","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO._random","page":"Reference","title":"AOCoptimizer.QUBO._random","text":"_random(rng::AbstractRNG, q::qubo{T})::AbstractVector{T} where {T<:Real}\n\nGenerates a random assignment for the QUBO problem q using the provided random number generator rng.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.greedy_random","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.greedy_random","page":"Reference","title":"AOCoptimizer.QUBO.greedy_random","text":"greedy_random(rng::Union{AbstractRNG, Integer}, q::qubo{T}, ctx::Union{Nothing,CancellationToken})\n\nPerforms a greedy random search on the QUBO problem q using the provided random number generator rng. The search continues until the cancellation token ctx is triggered. Returns a tuple containing the best energy found and the corresponding assignment.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.increase!","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.increase!","page":"Reference","title":"AOCoptimizer.QUBO.increase!","text":"increase!(assignment, terms, indices; ctx)\n\nTries to increase the objective function of an assignment applied to a set of QUBO terms by flipping assignments one-by-one according to the order in indices.\n\nIf cancellation token ctx is present, then process will continue until the entire list of indices gets visited, or cancellation token ctx gets triggered.\n\nMethod returns true if progress has been made; false otherwise\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUBO.decrease!","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUBO.decrease!","page":"Reference","title":"AOCoptimizer.QUBO.decrease!","text":"decrease(assignment, terms, indices; ctx)\n\nTries to decrease the objective function of an assignment applied to a set of QUBO terms by flipping assignments one-by-one according to the order in indices.\n\nIf cancellation token ctx is present, then process will continue until the entire list of indices gets visited, or cancellation token ctx gets triggered.\n\nMethod returns true if progress has been made; false otherwise\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#QUMO","page":"Reference","title":"QUMO","text":"","category":"section"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.mixed_ising","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.mixed_ising","text":"mixed_ising{T}\n\nA structure representing a Mixed Ising problem. Such problems are always minimization problems and, unlike traditional Ising problems, they can contain both binary and continuous variables. The continuous variables have a range of [-1, 1], while the binary variables are in {-1, 1}.\n\nThe mixed_ising structure contains:\n\nQuadratic: A matrix representing the quadratic terms of the Ising problem.\nField: A vector representing the linear terms of the Ising problem.\nBinary: A vector of booleans indicating whether each variable is binary.\nOffset: A constant offset added to the objective function.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.qumo","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.qumo","page":"Reference","title":"AOCoptimizer.QUMO.qumo","text":"qumo{T}\n\nA structure representing a Quadratic Unconstrained Mixed Optimization (QUMO). Such problems can be either minimization or maximization problems. They can contain both binary and continuous variables, but the continuous variables are expected to be in the range [-1, 1] and the binary variables are in {0, 1}. The objective function is (1/2)x'Qx + f'x + c, where x is the vector of variables, Q is the quadratic matrix, f is the linear vector (if it exists), and c is a constant offset.\n\nThe qumo structure contains the following fields:\n\nSense: The direction of optimization, either MINIMIZATION or MAXIMIZATION.\nQuadratic: A matrix representing the quadratic terms of the QUMO problem.\nField: A vector representing the linear terms of the QUMO problem.\nBinary: A vector of booleans indicating whether each variable is binary.\nOffset: A constant offset added to the objective function.\n\nIt is expected that the Quadratic matrix is symmetric and that the diagonal elements that correspond to binary variables are zero. (This is not checked in the constructor.)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"Base.isapprox","category":"page"},{"location":"reference/reference/#Base.isapprox","page":"Reference","title":"Base.isapprox","text":"isapprox(q1::qumo, q2::qumo; kwargs...)\n\nChecks if two qumo objects are approximately equal, i.e., have the same optimization direction and approximately the same weights in the quadratic and linear terms. They should also have the same binary and continuous variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.number_of_variables","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.number_of_variables","page":"Reference","title":"AOCoptimizer.QUMO.number_of_variables","text":"number_of_variables(q::Union{qumo{T}, mixed_ising{T}})::Integer where {T<:Real}\n\nReturns the number of variables in the QUMO or Mixed Ising problem q.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.convert_mixed_ising_to_positive_qumo","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_mixed_ising_to_positive_qumo","page":"Reference","title":"AOCoptimizer.QUMO.convert_mixed_ising_to_positive_qumo","text":"convert_mixed_ising_to_positive_qumo(m::mixed_ising{T})::qumo{T} where T<:Real\n\nConverts a mixed Ising problem, i.e. a problem where binaries are -1 1 and continuous in -1 1 to positive QUMO, where all variables are expected to be positive (binary in 01, continuous in 01).\n\nThe transformation is achieved by observing that we need to scale all variables x by (x+1)2 to move from -11 to 01. Observe, that the optimization objective is (12)xQx + fx + c.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.convert_positive_qumo_to_mixed_ising","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_positive_qumo_to_mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.convert_positive_qumo_to_mixed_ising","text":"convert_positive_qumo_to_mixed_ising(q::qumo{T})::mixed_ising{T} where {T<:Real}\n\nConverts a positive QUMO problem, i.e. a problem where all variables are expected to be positive (binary in 01, continuous in 01) to mixed Ising, where binaries are -1 1 and continuous in -1 1.\n\nThe transformation is achieved by observing that we need to scale all variables x by 2x-1 to move from 01 to -11. Observe, that the optimization objective is (12)xQx + fx + c.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.convert_to_qumo","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_to_qumo","page":"Reference","title":"AOCoptimizer.QUMO.convert_to_qumo","text":"convert_to_qumo(q::mixed_ising{T})::qumo{T} where {T<:Real}\n\nConverts a mixed Ising problem, i.e., a problem where binaries are -1 1 and continuous in -1 1 to QUMO, where binaries are in 0 1 and continuous stay at -1 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/","page":"Reference","title":"Reference","text":"QUMO.convert_to_mixed_ising","category":"page"},{"location":"reference/reference/#AOCoptimizer.QUMO.convert_to_mixed_ising","page":"Reference","title":"AOCoptimizer.QUMO.convert_to_mixed_ising","text":"convert_to_mixed_ising(q::qumo{T})::mixed_ising{T} where {T<:Real}\n\nConverts a QUMO problem to a mixed Ising problem. The transformation is achieved by observing that we need to map all binary variables from {0, 1} to {-1, 1}.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/example/#Simple-example","page":"Simple example","title":"Simple example","text":"","category":"section"},{"location":"submodules/Algorithms/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = AOCoptimizer.Algorithms\nDocTestSetup = quote\n    import AOCoptimizer as AOC\n    import AOCoptimizer.Algorithms as Algos\nend\nDocTestFilters = [r\"AOCoptimizer|AOC|Algos\"]","category":"page"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms","page":"API Reference","title":"AOCoptimizer.Algorithms","text":"","category":"section"},{"location":"submodules/Algorithms/reference/#Enhanced-Random","page":"API Reference","title":"Enhanced Random","text":"","category":"section"},{"location":"submodules/Algorithms/reference/","page":"API Reference","title":"API Reference","text":"EnhancedRandom.search","category":"page"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms.EnhancedRandom.search","page":"API Reference","title":"AOCoptimizer.Algorithms.EnhancedRandom.search","text":"search(rng::AbstractRNG, matrix::AbstractMatrix{T}, ctx::CancellationToken)\nsearch(seed::Integer, matrix::AbstractMatrix{T}, ctx::CancellationToken)\nsearch(rng::AbstractRNG, matrix::AbstractMatrix{T}, field::AbstractVector{T}, ctx::CancellationToken)\nsearch(seed::Integer, matrix::AbstractMatrix{T}, field::AbstractVector{T}, ctx::CancellationToken)\n\nImplement a simple heuristic that tries to solve Ising problems, by starting from a number of random solutions and sequentially trying to improve them using single flips.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Algorithms/reference/","page":"API Reference","title":"API Reference","text":"EnhancedRandom.search_qumo","category":"page"},{"location":"submodules/Algorithms/reference/#AOCoptimizer.Algorithms.EnhancedRandom.search_qumo","page":"API Reference","title":"AOCoptimizer.Algorithms.EnhancedRandom.search_qumo","text":"search_qumo(rng::AbstractRNG, quadratic::QuadraticMatrix{T}, linear::AbstractVector{T}, ctx::CancellationToken)\nsearch_qumo(seed::Integer, quadratic::QuadraticMatrix{T}, linear::AbstractVector{T}, ctx::CancellationToken)\nsearch_qumo(rng::AbstractRNG, quadratic::QuadraticMatrix{T}, ctx::CancellationToken)\nsearch_qumo(seed::Integer, quadratic::QuadraticMatrix{T}, ctx::CancellationToken)\n\nImplement a simple heuristic that tries to solve QUMO problems, by starting from a number of random solutions and sequentially trying to improve them using single flips.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = AOCoptimizer.FileFormats\nDocTestSetup = quote\n    import AOCoptimizer as AOC\n    import AOCoptimizer.FileFormats as FF\nend\nDocTestFilters = [r\"AOCoptimizer|AOC|FF\"]","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats","page":"API Reference","title":"AOCoptimizer.FileFormats","text":"","category":"section"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"FileNotFoundException","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.FileNotFoundException","page":"API Reference","title":"AOCoptimizer.FileFormats.FileNotFoundException","text":"FileNotFoundException(filename::AbstractString, message::AbstractString)\n\nException thrown when a file does not exist.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"GraphIOException","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.GraphIOException","page":"API Reference","title":"AOCoptimizer.FileFormats.GraphIOException","text":"Exception thrown when encountering errors in parsing files\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/#Simple-graph-file-format","page":"API Reference","title":"Simple graph file format","text":"","category":"section"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"read_graph_matrix","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.read_graph_matrix","page":"API Reference","title":"AOCoptimizer.FileFormats.read_graph_matrix","text":"read_graph_matrix(io)\n\nRead an undirected graph from an I/O stream.\n\nThe format of the file should be:\n\nnumber_of_vertices number_of_edges\nendpoint_A_of_edge_1 endpoint_B_of_edge_1 weight_of_edge_1\nendpoint_A_of_edge_2 endpoint_B_of_edge_2 weight_of_edge_2\n....\n\n\n\n\n\nread_graph_matrix(filename)\n\nRead an undirected graph from a file with name filename.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"read_directed_graph_matrix","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.read_directed_graph_matrix","page":"API Reference","title":"AOCoptimizer.FileFormats.read_directed_graph_matrix","text":"read_directed_graph_matrix(io)\n\nRead a directed graph from an I/O stream.\n\nThe format of the file should be:\n\nnumber_of_vertices number_of_edges\nendpoint_A_of_edge_1 endpoint_B_of_edge_1 weight_of_edge_1\nendpoint_A_of_edge_2 endpoint_B_of_edge_2 weight_of_edge_2\n....\n\n\n\n\n\nread_directed_graph_matrix(filename)\n\nRead an undirected graph from a file with name filename.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/#QIO-File-Format","page":"API Reference","title":"QIO File Format","text":"","category":"section"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.QIOProblem","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QIOProblem","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QIOProblem","text":"QIOProblem\n\nAbstract type for QIO problems.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.Ising","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.Ising","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.Ising","text":"Ising{T<:Real} <: QIOProblem\n\nIsing problem type. Ising problems are represented with a matrix of coefficients and a vector of fields.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.QUBO","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QUBO","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QUBO","text":"QUBO{T<:Real} <: QIOProblem\n\nQUBO problem type. QUBO problems are represented as a matrix of coefficients. These instances do not contain linear terms.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.Metadata","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.Metadata","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.Metadata","text":"Metadata{T<:Real}\n\nMetadata for QIO problems. Metadata include the following fields:\n\nObjective: The objective value of the problem; this is the best known minimum or maximum value of the objective function.\nInstance: The name of the instance; this can be used to identify the problem.\nSense: The optimization direction (MINIMIZATION or MAXIMIZATION).\nNumberOfTerms: The number of terms in the problem.\nNumberOfInteractions: The number of interactions in the problem.\nMaxDegree: The maximum degree of the problem.\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.QIOException","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.QIOException","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.QIOException","text":"QIOException(msg::AbstractString)\n\nException thrown when encountering errors in parsing files\n\n\n\n\n\n","category":"type"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.read_qio","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.read_qio","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.read_qio","text":"read_qio(::Type{T}, filename::AbstractString)::QIOProblem where {T<:Real}\nread_qio(filename::AbstractString)::QIOProblem\nread_qio(::Type{T}, io::IO)::QIOProblem where {T<:Real}\nread_qio(io::IO)::QIOProblem\n\nRead a QIO problem from a file with name filename or from an IO stream io. Optional type parameter T specifies the elementary type used in the the problem (e.g., Float64 or Float32).\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.is_qubo","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.is_qubo","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.is_qubo","text":"is_qubo(::QIOProblem) -> Bool\n\nCheck if the problem is a QUBO problem.\n\n\n\n\n\n","category":"function"},{"location":"submodules/FileFormats/reference/","page":"API Reference","title":"API Reference","text":"QIO.is_ising","category":"page"},{"location":"submodules/FileFormats/reference/#AOCoptimizer.FileFormats.QIO.is_ising","page":"API Reference","title":"AOCoptimizer.FileFormats.QIO.is_ising","text":"is_ising(::QIOProblem) -> Bool\n\nCheck if the problem is an Ising problem.\n\n\n\n\n\n","category":"function"},{"location":"developer/TODOs/#TODOs","page":"TODOs","title":"TODOs","text":"","category":"section"},{"location":"developer/developer/#Developer-notes","page":"Developer notes","title":"Developer notes","text":"","category":"section"},{"location":"developer/developer/#Helpful-links","page":"Developer notes","title":"Helpful links","text":"","category":"section"},{"location":"developer/developer/","page":"Developer notes","title":"Developer notes","text":"Documentation of KernelAbstractions.jl","category":"page"},{"location":"changelog/","page":"Release Notes","title":"Release Notes","text":"CurrentModule = AOCoptimizer","category":"page"},{"location":"changelog/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"CurrentModule = AOCoptimizer","category":"page"},{"location":"release_notes/#Release-Notes","page":"Release notes","title":"Release Notes","text":"","category":"section"},{"location":"manual/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"CurrentModule = AOCoptimizer.Algorithms\nDocTestSetup = quote\n    import AOCoptimizer as AOC\n    import AOCoptimizer.Algorithms as Algos\nend\nDocTestFilters = [r\"AOCoptimizer|AOC|Algos\"]","category":"page"},{"location":"submodules/Algorithms/overview/#AOCoptimizer.Algorithms","page":"Overview","title":"AOCoptimizer.Algorithms","text":"","category":"section"},{"location":"submodules/Algorithms/overview/#Enhanced-Random","page":"Overview","title":"Enhanced Random","text":"","category":"section"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"This module implements a very simple heuristic for solving Ising and QUMO problems. It is based on the idea of starting from a random initial solution, and then iteratively flipping bits in the assignment vector to improve the objective function. The algorithm evaluated starting points in parallel and (typically) executes for a specified time limit. The achieved solution can be used as the lowest baseline that any reasonable algorithm should be able to beat.","category":"page"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"A very simple example of how to use it is shown below:","category":"page"},{"location":"submodules/Algorithms/overview/","page":"Overview","title":"Overview","text":"using AOCoptimizer: CancellationToken\nusing AOCoptimizer.RuntimeUtils: run_for\nusing AOCoptimizer.Algorithms.EnhancedRandom: search\n\nfunction _mk_solver(interactions::AbstractMatrix, seed::Integer)\n\n    function solve(ctx::CancellationToken)\n        # @debug \"Starting solver at $(now())\"\n        # @debug \"Graph: $interactions\"\n        # @debug \"Context: $ctx\"\n        result = search(seed, interactions, ctx)\n        # @debug \"Solver finished at $(now())\"\n        return result\n    end\n\n    return solve\nend\n\ninteractions = Float32.(-[\n    0 1 0 0\n    1 0 0 0\n    0 0 0 1\n    0 0 1 0\n])\nseed = 1234\ntime_limit = Second(2)\n\nsolver = _mk_solver(interactions, seed)\nresults = run_for(solver, time_limit; threads=2)\n\n(best_objective, best_index) = findmin(first, results)\nbest_assignment = results[best_index][2]\nprintln(\"Best objective: $best_objective\")\nprintln(\"Best (ising) assignment: $best_assignment\")","category":"page"},{"location":"#AOCoptimizer.jl","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Welcome to the documentation of the AOCoptimizer.jl Julia package. AOCoptimizer.jl is a package for solving Quadratic Unconstrained Mixed Optimization (QUMO) problems.","category":"page"},{"location":"#The-QUMO-Abstraction","page":"AOCoptimizer.jl","title":"The QUMO Abstraction","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"QUMO is a new abstraction designed for expressing practical optimization problems that aligns seamlessly with innovative hardware solutions (e.g., Project AOC). QUMO broadens the scope of the established models often referred to as Ising, Max-Cut, or Quadratic Unconstrained Binary Optimization (QUBO), by allowing continuous variables alongside binary variables. The QUMO extension allows a more natural expression of problems involving both continuous and binary (decision) variables, eliminating the need for the binarization of continuous variables that increases problem size. In addition, QUMO efficiently integrates inequality constraints by introducing a single continuous slack variable for each constraint. Hence, the QUMO abstraction represents practical problems using fewer variables and by staying closer to the original problem formulation, it often yields better solutions than QUBO.","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Formally, QUMO seeks an assignment to N variables bf x=leftx_1 ldots  x_Nright^T of the objective:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"  min_bf x -frac12 bf x^T cdot bf Q cdot bf x - bf q^Tcdot bf x =\n  min_bf x -frac12 sum_i=1^N Q_ii x^2_i -\n  frac12sum_substackij=1  i neq j^N Q_ijx_ix_j - sum_i=1^N q_i x_i","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"for a given matrix bf Q and vector bf q representing the problem. The variables can be either binary, i.e., x_i in 0 1, or continuous in the (closed) range, i.e., x_i in left-1 1right, while the matrix bf Q is symmetric, i.e., Q_ij = Q_ji. We do not require semi-definiteness or convexity for the input problem. The diagonal entries of bf Q are zero for the binary variables, as quadratic terms of the form Q_ii x_i^2 are equivalent to Q_ii x_i and, hence, can be incorporated into the relevant linear terms by updating q_i accordingly, i.e., q_i leftarrow q_i + 05cdot Q_ii and then Q_ii leftarrow 0.","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"For more details on the QUMO and related abstractions, please refer to the abstractions section of the documentation.","category":"page"},{"location":"#Installation-and-Usage","page":"AOCoptimizer.jl","title":"Installation and Usage","text":"","category":"section"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"In a nutshell, you can install the package using the Julia package manager:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"] add https://github.com/microsoft/AOCoptimizer.jl\n# or\nusing Pkg\nPkg.add(url=\"https://github.com/microsoft/AOCoptimizer.jl\", rev=\"main\")","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"After successful installation, you can use the package by loading it:","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"# if you want to use CUDA, first uncomment the following line to load CUDA.jl\n# using CUDA\nusing AOCoptimizer","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"Unit tests should also work correctly (it may take a while to finish):","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"] test AOCoptimizer\n# or\nusing Pkg\nPkg.test(\"AOCoptimizer\")","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"TODO: Add a simple example in the code above","category":"page"},{"location":"","page":"AOCoptimizer.jl","title":"AOCoptimizer.jl","text":"For more detailed installation instructions and related problems, please refer to the installation section of the documentation.","category":"page"}]
}
